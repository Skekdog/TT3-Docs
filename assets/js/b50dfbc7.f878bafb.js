"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[18],{2026:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"Maps/Interactables","title":"Interactables","description":"See also: Classes.Interactable.","source":"@site/docs/Maps/Interactables.md","sourceDirName":"Maps","slug":"/Maps/Interactables","permalink":"/TT3-Docs/Maps/Interactables","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Items","permalink":"/TT3-Docs/Maps/Items"},"next":{"title":"Bounds","permalink":"/TT3-Docs/Maps/Bounds"}}');var i=n(4848),r=n(8453);const s={sidebar_position:6},l="Interactables",o={},d=[{value:"Prefabs",id:"prefabs",level:2},{value:"Doors",id:"doors",level:3},{value:"Ladders",id:"ladders",level:3},{value:"Defined Interactables",id:"defined-interactables",level:2},{value:"Runtime Interactables",id:"runtime-interactables",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"interactables",children:"Interactables"})}),"\n",(0,i.jsxs)(t.p,{children:["See also: ",(0,i.jsx)(t.a,{href:"/TT3-Docs/Classes/Interactable",children:"Classes.Interactable"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["An interactable is a special kind of prop that a player can interact with. To make something into an interactable, you should add the ",(0,i.jsx)(t.code,{children:"Interactable"})," tag to it."]}),"\n",(0,i.jsxs)(t.p,{children:["Interactable models, including defined interactables, can have a ",(0,i.jsx)(t.code,{children:"DisplayName"})," attribute, this will override the name displayed to the player. For defined interactables, if a display name attribute is set, it will be used instead of the definition's display name."]}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["You also need the ",(0,i.jsx)(t.code,{children:"Prop"})," tag."]})}),"\n",(0,i.jsx)(t.p,{children:"Now, there are three kinds of interactables: prefabs, defined interactables, and runtime interactables."}),"\n",(0,i.jsx)(t.h2,{id:"prefabs",children:"Prefabs"}),"\n",(0,i.jsxs)(t.p,{children:["To make a part into a prefab interactable, you should add an additional tag, which is the name of the prefab. For example, to make a door, you should add the ",(0,i.jsx)(t.code,{children:"Door"})," tag.",(0,i.jsx)("br",{}),"\nCurrently, there are two prefab interactables:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Door"}),"\n",(0,i.jsx)(t.li,{children:"Ladder"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"doors",children:"Doors"}),"\n",(0,i.jsxs)(t.p,{children:["The door format is currently volatile and subject to change; thus, only the baseline is documented: you should add an ",(0,i.jsx)(t.code,{children:"Attachment"}),", named ",(0,i.jsx)(t.code,{children:"DoorPivot"}),", to the door. This attachment acts as the hinge of the door."]}),"\n",(0,i.jsx)(t.h3,{id:"ladders",children:"Ladders"}),"\n",(0,i.jsxs)(t.p,{children:["Unlike other interactables, ladders do not have to be under ",(0,i.jsx)(t.code,{children:"Dynamic"}),". Players will climb ladders automatically when they touch them. Typically, ladders should be taller than their actual height, but shorter at the bottom.",(0,i.jsx)("br",{}),"\nIf your ladder acts strangely, double-check the orientation."]}),"\n",(0,i.jsx)(t.h2,{id:"defined-interactables",children:"Defined Interactables"}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsx)(t.p,{children:"Defined interactables usually require some level of scripting knowledge; however, they are not complicated if you do have some scripting capability."})}),"\n",(0,i.jsx)(t.p,{children:"Defined interactables are designed to be used in multiple places around a map, using the same code. All current game interactables, like the Radio and the C4, are defined."}),"\n",(0,i.jsx)(t.p,{children:"To make a defined interactable, you should create a ModuleScript in your map. Give it an appropriate name (usually the name of the interactable, although it doesn't strictly matter)."}),"\n",(0,i.jsx)(t.p,{children:"Now, you should require the module in your MapScript and add it to the InteractableDefinitions table:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-lua",children:"TerrainColors = ...,\n\nInteractableDefinitions = {\n\tInteractableName = require(script.Path.To.Your.Module)\n},\n\nAvailableItems = ...,\n"})}),"\n",(0,i.jsx)(t.p,{children:"This will register all props with the Interactable tag and the matching name as having this interactable definition."}),"\n",(0,i.jsx)(t.p,{children:"If you attempt to load your map now, it will break. You now need to define the interactable, so head back into your module and get coding!"}),"\n",(0,i.jsxs)(t.p,{children:["The module should return an ",(0,i.jsx)(t.code,{children:"InteractableDefinition"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-lua",children:"export type InteractableDefinition = {\n    Name: string, -- This must match the name of the interactable in the map.\n    DisplayName: string?, -- Overrides the name when displayed to players.\n\n    NoActionHint: boolean?, -- If true, hides the action hint.\n    HideName: boolean?, -- If true, hides the name. Unlike in runtime interactables, this property is not overriden by DisplayName.\n\n    DefaultHintText: string?, -- Sets the default hint shown to players.\n\n    Model: MapObject?, -- When defining interactables for maps, you should leave this `nil`.\n\n    IsContinuousInteraction: boolean, -- If true, OnInteract will be called repeatedly until the player releases the interaction key or moves out of range.\n    InteractionRange: number, -- The maximum distance at which the player can interact with the interactable.\n\n    OnInteractClient: ((object: Interactable) -> ())?, -- Called on the client when the player interacts with the interactable.\n    OnInteractServer: ((object: Interactable, participant: Participant) -> ())?, -- Called on the server when the participant interacts with the interactable.\n\n    OnLoadClient: ((object: Interactable) -> ())?, -- Called on the client when the interactable is first loaded in the map.\n    OnLoadServer: ((object: Interactable) -> ())?, -- Called on the server when the interactable is first loaded in the map.\n\n    OnBreakServer: ((object: Interactable, params: DamageParams) -> ())?, -- Called on the server when the interactable is destroyed.\n\n    BeforeTakeDamage: ((object: Interactable, params: DamageParams) -> boolean)?, -- Called on the server before the interactable takes damage. If this returns false, the damage will not be applied.\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"runtime-interactables",children:"Runtime Interactables"}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsx)(t.p,{children:"Like defined interactables, runtime interactables require some level of scripting knowledge; however, they are not complicated if you do have some scripting capability, and they are somewhat easier to understand than defined interactables."})}),"\n",(0,i.jsxs)(t.p,{children:["Runtime Interactables do not use a centralized definition; instead, their properties are defined as attributes, and their behaviour is provided by two ",(0,i.jsx)(t.code,{children:"ModuleScripts"}),", one for the client and one for the server."]}),"\n",(0,i.jsxs)(t.p,{children:["To turn a prop into a runtime interactable, give it the ",(0,i.jsx)(t.code,{children:"Interactable"})," tag and add an attribute, named ",(0,i.jsx)(t.code,{children:"Button"}),", and set it to the boolean: ",(0,i.jsx)(t.code,{children:"true"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"Additional attributes:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"DisplayName"}),": ",(0,i.jsx)(t.code,{children:"string?"})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"UseText"}),": ",(0,i.jsx)(t.code,{children:"string?"})," - This is the equivalent of DefaultHintText in defined interactables."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"ShowName"}),": ",(0,i.jsx)(t.code,{children:"boolean?"})," - By default, runtime interactables do not show their name. However, you can set DisplayName to a string or ShowName to true to show the name."]}),"\n"]}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsx)(t.p,{children:"Runtime interactables currently cannot set a custom interaction range, it is always set to 7.5."})}),"\n",(0,i.jsxs)(t.p,{children:["The client ",(0,i.jsx)(t.code,{children:"ModuleScript"})," ",(0,i.jsx)(t.strong,{children:"must"})," be named ",(0,i.jsx)(t.code,{children:"ButtonClient"}),". It should return a table of the following type:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-lua",children:"export type ButtonClient = {\n\tBegan = () -> (),\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The server ",(0,i.jsx)(t.code,{children:"ModuleScript"})," ",(0,i.jsx)(t.strong,{children:"must"})," be named ",(0,i.jsx)(t.code,{children:"ButtonServer"}),". It should return a table of the following type:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-lua",children:"export type ButtonServer = {\n\tBegan = (player: Player) -> (),\n}\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"warning",children:(0,i.jsxs)(t.p,{children:["Unlike other map code, ButtonServer receives a ",(0,i.jsx)(t.code,{children:"Player"})," instance instead of a ",(0,i.jsx)(t.code,{children:"Participant"}),"."]})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>l});var a=n(6540);const i={},r=a.createContext(i);function s(e){const t=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);