"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[18],{2026:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"Maps/Interactables","title":"Interactables","description":"See also: Classes.Interactable.","source":"@site/docs/Maps/Interactables.md","sourceDirName":"Maps","slug":"/Maps/Interactables","permalink":"/TT3-Docs/Maps/Interactables","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Items","permalink":"/TT3-Docs/Maps/Items"},"next":{"title":"Bounds","permalink":"/TT3-Docs/Maps/Bounds"}}');var i=t(4848),r=t(8453);const s={sidebar_position:6},o="Interactables",l={},d=[{value:"Prefabs",id:"prefabs",level:2},{value:"Doors",id:"doors",level:3},{value:"Ladders",id:"ladders",level:3},{value:"Defined Interactables",id:"defined-interactables",level:2},{value:"Runtime Interactables",id:"runtime-interactables",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"interactables",children:"Interactables"})}),"\n",(0,i.jsxs)(n.p,{children:["See also: ",(0,i.jsx)(n.a,{href:"/TT3-Docs/Classes/Interactable",children:"Classes.Interactable"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["An interactable is a special kind of prop that a player can interact with. To make something into an interactable, you should add the ",(0,i.jsx)(n.code,{children:"Interactable"})," tag to it."]}),"\n",(0,i.jsxs)(n.p,{children:["Interactable models, including defined interactables, can have a ",(0,i.jsx)(n.code,{children:"DisplayName"})," attribute, this will override the name displayed to the player. For defined interactables, if a display name attribute is set, it will be used instead of the definition's display name."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["You also need the ",(0,i.jsx)(n.code,{children:"Prop"})," tag."]})}),"\n",(0,i.jsx)(n.p,{children:"Now, there are three kinds of interactables: prefabs, defined interactables, and runtime interactables."}),"\n",(0,i.jsx)(n.h2,{id:"prefabs",children:"Prefabs"}),"\n",(0,i.jsxs)(n.p,{children:["To make a part into a prefab interactable, you should add an additional tag, which is the name of the prefab. For example, to make a door, you should add the ",(0,i.jsx)(n.code,{children:"Door"})," tag.",(0,i.jsx)("br",{}),"\nCurrently, there are two prefab interactables:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Door"}),"\n",(0,i.jsx)(n.li,{children:"Ladder"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"doors",children:"Doors"}),"\n",(0,i.jsxs)(n.p,{children:["There are two types of doors: hinge doors and sliding doors. Hinge doors are created by added an ",(0,i.jsx)(n.code,{children:"Attachment"})," with the name ",(0,i.jsx)(n.code,{children:"DoorPivot"})," to the primary part of the door, which (unsurprisingly) acts as the hinge for the door. Sliding doors do not have a ",(0,i.jsx)(n.code,{children:"DoorPivot"}),", and instead are created by setting the ",(0,i.jsx)(n.code,{children:"DoorKind"})," attribute (on the door model, not the primary part) to ",(0,i.jsx)(n.code,{children:"Slide"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Doors have a number of attributes which can be used for customisation. These attributes are all set on the door model, which may be a part or a model:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"DoorKind"}),": ",(0,i.jsx)(n.code,{children:"Hinge"})," or ",(0,i.jsx)(n.code,{children:"Slide"})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Duration"}),": The time it takes to open or close the door, in seconds. Defaults to 0.75s."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"OpeningDuration"}),": The time it takes to open the door, in seconds. If set, overrides ",(0,i.jsx)(n.code,{children:"Duration"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ClosingDuration"}),": The time it takes to close the door, in seconds. If set, overrides ",(0,i.jsx)(n.code,{children:"Duration"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"AutoCloseAfter"}),": The time after the door has fully opened after which it will automatically close, in seconds. By default, doors will not close automatically."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Locked"}),": If true, the door cannot be opened by players. It may still be possible to open the door programmatically."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"EasingStyle"}),": The easing style to use when opening or closing the door. Defaults to ",(0,i.jsx)(n.code,{children:"Linear"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"EasingDirection"}),": The easing direction to use when opening or closing the door. Defaults to ",(0,i.jsx)(n.code,{children:"In"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Additionally, sliding doors have a ",(0,i.jsx)(n.code,{children:"SlideAxis"})," attribute, a ",(0,i.jsx)(n.code,{children:"Vector3"})," which determines the axis along which the door slides."]}),"\n",(0,i.jsxs)(n.p,{children:["Doors can also have customised open and close sounds. To do this, you should add a ",(0,i.jsx)(n.code,{children:"Sounds"})," folder to the door model, with two subfolders, ",(0,i.jsx)(n.code,{children:"Open"})," and ",(0,i.jsx)(n.code,{children:"Close"}),". These folders should contain one or more ",(0,i.jsx)(n.code,{children:"Sound"})," objects."]}),"\n",(0,i.jsx)(n.h3,{id:"ladders",children:"Ladders"}),"\n",(0,i.jsxs)(n.p,{children:["Unlike other interactables, ladders do not have to be under ",(0,i.jsx)(n.code,{children:"Dynamic"}),". Players will climb ladders automatically when they touch them. Typically, ladders should be taller than their actual height, but shorter at the bottom.",(0,i.jsx)("br",{}),"\nIf your ladder acts strangely, double-check the orientation."]}),"\n",(0,i.jsx)(n.h2,{id:"defined-interactables",children:"Defined Interactables"}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"Defined interactables usually require some level of scripting knowledge; however, they are not complicated if you do have some scripting capability."})}),"\n",(0,i.jsx)(n.p,{children:"Defined interactables are designed to be used in multiple places around a map, using the same code. All current game interactables, like the Radio and the C4, are defined."}),"\n",(0,i.jsx)(n.p,{children:"To make a defined interactable, you should create a ModuleScript in your map. Give it an appropriate name (usually the name of the interactable, although it doesn't strictly matter)."}),"\n",(0,i.jsx)(n.p,{children:"Now, you should require the module in your MapScript and add it to the InteractableDefinitions table:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"TerrainColors = ...,\n\nInteractableDefinitions = {\n\tInteractableName = require(script.Path.To.Your.Module)\n},\n\nAvailableItems = ...,\n"})}),"\n",(0,i.jsx)(n.p,{children:"This will register all props with the Interactable tag and the matching name as having this interactable definition."}),"\n",(0,i.jsx)(n.p,{children:"If you attempt to load your map now, it will break. You now need to define the interactable, so head back into your module and get coding!"}),"\n",(0,i.jsxs)(n.p,{children:["The module should return an ",(0,i.jsx)(n.code,{children:"InteractableDefinition"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"export type InteractableDefinition = {\n    Name: string, -- This must match the name of the interactable in the map.\n    DisplayName: string?, -- Overrides the name when displayed to players.\n\n    NoActionHint: boolean?, -- If true, hides the action hint.\n    HideName: boolean?, -- If true, hides the name. Unlike in runtime interactables, this property is not overriden by DisplayName.\n\n    DefaultHintText: string?, -- Sets the default hint shown to players.\n\n    Model: MapObject?, -- When defining interactables for maps, you should leave this `nil`.\n\n    IsContinuousInteraction: boolean, -- If true, OnInteract will be called repeatedly until the player releases the interaction key or moves out of range.\n    InteractionRange: number, -- The maximum distance at which the player can interact with the interactable.\n\n    OnInteractClient: ((object: Interactable) -> ())?, -- Called on the client when the player interacts with the interactable.\n    OnInteractServer: ((object: Interactable, participant: Participant) -> ())?, -- Called on the server when the participant interacts with the interactable.\n\n    OnLoadClient: ((object: Interactable) -> ())?, -- Called on the client when the interactable is first loaded in the map.\n    OnLoadServer: ((object: Interactable) -> ())?, -- Called on the server when the interactable is first loaded in the map.\n\n    OnBreakServer: ((object: Interactable, params: DamageParams) -> ())?, -- Called on the server when the interactable is destroyed.\n\n    BeforeTakeDamage: ((object: Interactable, params: DamageParams) -> boolean)?, -- Called on the server before the interactable takes damage. If this returns false, the damage will not be applied.\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"runtime-interactables",children:"Runtime Interactables"}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"Like defined interactables, runtime interactables require some level of scripting knowledge; however, they are not complicated if you do have some scripting capability, and they are somewhat easier to understand than defined interactables."})}),"\n",(0,i.jsxs)(n.p,{children:["Runtime Interactables do not use a centralized definition; instead, their properties are defined as attributes, and their behaviour is provided by two ",(0,i.jsx)(n.code,{children:"ModuleScripts"}),", one for the client and one for the server."]}),"\n",(0,i.jsxs)(n.p,{children:["To turn a prop into a runtime interactable, give it the ",(0,i.jsx)(n.code,{children:"Interactable"})," tag and add an attribute, named ",(0,i.jsx)(n.code,{children:"Button"}),", and set it to the boolean: ",(0,i.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Additional attributes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"DisplayName"}),": ",(0,i.jsx)(n.code,{children:"string?"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"UseText"}),": ",(0,i.jsx)(n.code,{children:"string?"})," - This is the equivalent of DefaultHintText in defined interactables."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ShowName"}),": ",(0,i.jsx)(n.code,{children:"boolean?"})," - By default, runtime interactables do not show their name. However, you can set DisplayName to a string or ShowName to true to show the name."]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"Runtime interactables currently cannot set a custom interaction range, it is always set to 7.5."})}),"\n",(0,i.jsxs)(n.p,{children:["The client ",(0,i.jsx)(n.code,{children:"ModuleScript"})," ",(0,i.jsx)(n.strong,{children:"must"})," be named ",(0,i.jsx)(n.code,{children:"ButtonClient"}),". It should return a table of the following type:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"export type ButtonClient = {\n\tBegan = () -> (),\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The server ",(0,i.jsx)(n.code,{children:"ModuleScript"})," ",(0,i.jsx)(n.strong,{children:"must"})," be named ",(0,i.jsx)(n.code,{children:"ButtonServer"}),". It should return a table of the following type:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"export type ButtonServer = {\n\tBegan = (player: Player) -> (),\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["Unlike other map code, ButtonServer receives a ",(0,i.jsx)(n.code,{children:"Player"})," instance instead of a ",(0,i.jsx)(n.code,{children:"Participant"}),"."]})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var a=t(6540);const i={},r=a.createContext(i);function s(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);