"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7650],{6764:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>d,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"Maps/Structure","title":"Structure","description":"The best way to learn the map structure is by example, which you can find in the SDK plugin.","source":"@site/docs/Maps/Structure.md","sourceDirName":"Maps","slug":"/Maps/Structure","permalink":"/Traitor-Docs/Maps/Structure","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Intro","permalink":"/Traitor-Docs/Maps/Intro"},"next":{"title":"Props","permalink":"/Traitor-Docs/Maps/Props"}}');var s=t(4848),i=t(8453);const d={sidebar_position:2},o="Structure",c={},l=[];function a(e){const r={admonition:"admonition",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"structure",children:"Structure"})}),"\n",(0,s.jsx)(r.admonition,{type:"info",children:(0,s.jsx)(r.p,{children:"The best way to learn the map structure is by example, which you can find in the SDK plugin."})}),"\n",(0,s.jsx)(r.p,{children:"Your map should follow a certain structure:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"- Map (Folder)\n\t- Static (Folder)\n\t- Dynamic (Folder)\n\t- PlayerSpawns (Folder)\n"})}),"\n",(0,s.jsx)(r.p,{children:"Static geometry should be placed in the Static folder. This folder will be loaded once per map rotation; therefore, parts here should be anchored and unmoving. Parts which do move, like props, items, doors, and other movable objects should be placed in the Dynamic folder - this folder will be reloaded every round. You can follow this through for scripts as well - scripts in the Dynamic folder will be reloaded every round, and scripts in the Static folder will be loaded once per map rotation."}),"\n",(0,s.jsx)(r.p,{children:"Maps also must have certain attributes on the root folder:"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Attribute"}),(0,s.jsx)(r.th,{children:"Type"}),(0,s.jsx)(r.th,{children:"Description"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Authors"})}),(0,s.jsx)(r.td,{children:"string"}),(0,s.jsx)(r.td,{children:'The map creators. Usually, users are referenced by their username, prefixed by an "@".'})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Icon"})}),(0,s.jsx)(r.td,{children:"string"}),(0,s.jsxs)(r.td,{children:["The map's icon shown in voting. This should be an asset string, in the form ",(0,s.jsx)(r.code,{children:"rbxassetid://ID"}),"."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Description"})}),(0,s.jsx)(r.td,{children:"string"}),(0,s.jsx)(r.td,{children:"The map's description. This is not currently shown anywhere, but it may be used in the future."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"DisplayName"})}),(0,s.jsx)(r.td,{children:"string?"}),(0,s.jsx)(r.td,{children:"The map's display name. This is shown in voting. If not specified, the root folder name will be used."})]})]})]}),"\n",(0,s.jsx)(r.p,{children:"Additionally, maps contain other instances which are auto-generated by the SDK plugin when you publish your map:"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Instance"}),(0,s.jsx)(r.th,{children:"Description"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Terrain"})}),(0,s.jsx)(r.td,{children:"The map's terrain. This is generated based on the terrain in the place file you are editing."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Clouds"})}),(0,s.jsxs)(r.td,{children:["The map's clouds. If you have clouds under ",(0,s.jsx)(r.code,{children:"workspace.Terrain"}),", they will be copied here."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"LightingSettings"})}),(0,s.jsx)(r.td,{children:"The map's lighting settings. This will be generated based on the Lighting service, any children will additionally be copied here."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"WaterSettings"})}),(0,s.jsx)(r.td,{children:"The map's water settings. This will be generated based on the Terrain instance."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"TerrainColors"})}),(0,s.jsx)(r.td,{children:"The map's terrain colors. This will be generated based on the Terrain instance."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"MaterialVariants"})}),(0,s.jsx)(r.td,{children:"The map's material variants. This will be generated based on MaterialService; children there will be copied here."})]})]})]})]})}function h(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,r,t)=>{t.d(r,{R:()=>d,x:()=>o});var n=t(6540);const s={},i=n.createContext(s);function d(e){const r=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),n.createElement(i.Provider,{value:r},e.children)}}}]);